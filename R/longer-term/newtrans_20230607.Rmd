---
title: "newtrans_20230607"
author: "Yunfeng Yang"
date: "2023-06-07"
output: html_document
---

# Damage model 
The original model is 

\begin{equation}\label{eq: original model}
y^*  = y \cdot I\{c \cdot y > l\} + \alpha \cdot y \cdot I\{c \cdot y < l\}
\end{equation}

<!-- We may first consider a simplified version without the tuning parameter $c$. -->
<!-- \begin{equation}\label{eq: simplified model} -->
<!-- y^*  = y \cdot I\{ y > l\} + \alpha \cdot y \cdot I\{y < l\} -->
<!-- \end{equation} -->

# Smooth function

Note that we have the indicator function in the model we might consider the smooth function:
\begin{equation}\label{eq: trans function}
S(x;s) = \frac{1}{1 + \exp(-s \cdot x)}
\end{equation},
where $s$ is the smoothing hyper-parameter to control the smoothness. 

```{r}
smooth_ind <- function(x,s){
  return(1/(1+exp(-x*s)))
}
x <- seq(from = -10, to= 10, length.out = 500)
plot(x,ifelse(x>0,1,0),type = "l")
lines(x,sapply(x,smooth_ind, s = 1),type = "l",col = "red")
lines(x,sapply(x,smooth_ind, s = 10),type = "l",col = "blue")
lines(x,sapply(x,smooth_ind, s = 100),type = "l",col = "green")
legend("topleft", legend=c("Indicator", "s = 1", "s = 10", "s = 100"),
       col=c("black","red", "blue","green"), lty=1, cex=0.8)
```


Then the model becomes 
$$
y^*  = y \cdot \frac{1}{1 + \exp(-s\cdot(cy-l))} + \alpha \cdot y \cdot \frac{1}{1 + \exp(-s\cdot(l-cy))}
$$
# the plot 
```{r}
### new 
N <- 1000
mu <- 48
sigma <- 19
#y <- rnorm(N,mean = mu, sd = sigma)
y <- seq(from = 0.1, to = 100, length = 500)
l <-  32
alpha <- 0.5
c <- 0.8
s <- 10
ystar <- y*smooth_ind(c*y-l,s )+ alpha*smooth_ind(l-c*y,s)

plot(y,ystar,type = 'l',lty = 1)
lines(y,y,lty = 2)
legend("topleft", legend = c("ystar","y"),lty=1:2)
```

We have $y \geq y^*$.

The lumber have three groups:

- Group 1: $y <l$, $y^* < l$, i.e., $y^* <y < l$
- Group 2: $y >l$, $y^* < l$, i.e. $y^*<l<y$. This groups we only knows how many pieces. 
- Group 3: $y >l$, $y^* > l$, i.e. $l<y^*<y$.


# The PDF calculation 

Given $Y \sim N(\mu, \sigma^2)$, $Y^* = h(Y)$. Then the pdf of $Y^*$,
$$
f_{Y^*}(y^*) = f_{Y}(h^{-1}(y^*))|\frac{d}{dy^*}h^{-1}(y^*)|,
$$
where $f_Y()$ is the pdf of $Y$, i.e., normal. 


Following this, We need the numerical function of $h^{-1}(y^*)$, and its numerical gradient $\frac{d}{dy^*}h^{-1}(y^*)$. (The analytical form doesn't seem available.)
```{r}
#' The damage model, smoothed version of 
#' "y* = y* I(c*x > l) + alpha * y * I(c*x < l)"
#' 
#' @param y, the original strength
#' @param alpha, the damage parameter
#' @param l, the proof loading level
#' @param c, the threshold parameter. Damage effects happen exceeding c.
#' @param s, the temperature parameter for s
#' @return, the weakened y*, y*<y.
dmg_model <- function(y,alpha,l,c,s){
  return(y*smooth_ind(c*y-l,s)+ alpha*smooth_ind(l-c*y,s))
}

#' The damage-inverse model, given a weakened ystar, find the original y
#' 
#' @param ystar, the weakened strength
#' @param alpha, the damage parameter
#' @param l, the proof loading level
#' @param c, the threshold parameter. Damage effects happen exceeding c.
#' @param s, the temperature parameter for s
#' @return, the original y, y>y*.
dmg_inverse <- function(ystar,alpha,l,c,s){
  uniroot((function (x) dmg_model(x,alpha,l,c,s) - ystar), lower = 0, upper = 1000)$root
}
# the abs gradient at damage-inverse
dmg_inverse_grad <- function(ystar,alpha,l,c,s){
  abs(numDeriv::grad(func = (function(x) dmg_inverse(x,alpha,l,c,s)),
                 x  = ystar))
}  
#dmg_inverse_grad(42,a lpha,l,c,s)
#ystar <- y*smooth_ind(c*y-l)+ alpha*smooth_ind(l-c*y)

dmglik <- function(ystar,alpha,l,c,s,mu,sigma){
  y <- dmg_inverse(ystar,alpha,l,c,s)
  dnorm(y, mean = mu, sd = sigma, log = TRUE)+ log(dmg_inverse_grad(ystar,alpha,l,c,s))
}
```

```{r}
## plot 
set.seed(8888)
N <- 1000
mu <- 48
sigma <- 19
#y <- rnorm(N,mean = mu, sd = sigma)
l <-  32
alpha <- 0.2
c <- 0.8
s <- 1
```

```{r}
## data 

y <- rnorm(N, mean = mu, sd = sigma )

y_obs <- list()
# group 1, y^* <y < l
y_obs$group1 <- y[which(y < l)]
# group 2, y^*<l<y
group23 <- y[which(y > l)]
group23_star <- dmg_model(group23,alpha,l,c,s)
y_obs$group2 <- length(group23[which(group23 > l &group23_star < l)])
y_obs$group3 <- group23[which(group23_star >l)]

negdmglik_model <- function(theta){
  mu <- theta[1]
  sigma <- theta[2]
  alpha <- theta[3]
  c <- theta[4]
  
  lik1 <- sum(dnorm(y_obs$group1,mean = mu, sd = sigma, log = TRUE))
  lik2 <- y_obs$group2 * log(
    pnorm(dmg_inverse(l,alpha,l,c,s), mean = mu, sd = sigma) -
      pnorm(l, mean = mu, sd = sigma)
  )
  #lik2 <- 0
  lik3 <- sum(sapply(y_obs$group3,dmglik,alpha,l,c,s,mu,sigma))
  return(-lik1-lik2-lik3)
}

```




```{r}
theta0 <- c(mu,sigma,alpha,c)
optimCheck::optim_proj(theta0,
                       negdmglik_model,xrng = .5,
                       xnames = c("mu","sigma","alpha","c"))
```

