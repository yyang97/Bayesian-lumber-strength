xnames = c("mu","sigma","alpha","c"))
theta_opt <- optimout$par
theta_opt[3] <- expit(theta_opt[3])
optimCheck::optim_proj(theta_opt,
negdmglik_model_unconstraint ,xrng = .5,
xnames = c("mu","sigma","alpha","c"))
theta_0 <- c(47.9985218, 18.9804222,logit(0.4548490),  0.6515348)
negdmglik_model(theta_0)
optimout <- optim(par = theta_0,
fn = negdmglik_model,
gr = negdmglik_model_grad,
method = "BFGS")
optimout$par
expit(optimout$par[3])
optimout
s <- 1
negdmglik_model_unconstraint <- function(theta){
mu <- theta[1]
sigma <- theta[2]
# alpha <- theta[3]
alpha <- theta[3]
c <- theta[4]
lik1 <- sum(dnorm(R20_data,mean = mu, sd = sigma, log = TRUE))
lik2 <- g2 * log(
pnorm(dmg_inverse(l,alpha,l,c,s), mean = mu, sd = sigma) -
pnorm(l, mean = mu, sd = sigma)
)
#lik2 <- 0
lik3 <- sum(sapply(R20R100_data,dmglik,alpha,l,c,s,mu,sigma))
lik4 <- sum(dnorm(R100_data,mean = mu, sd = sigma, log = TRUE))
return(-lik1-lik2-lik3-lik4)
}
theta_opt <- optimout$par
theta_opt[3] <- expit(theta_opt[3])
optimCheck::optim_proj(theta_opt,
negdmglik_model_unconstraint ,xrng = .5,
xnames = c("mu","sigma","alpha","c"))
negdmglik_alpha <- function(alpha){
mu <- 47.9985218
sigma <- 18.9804222
# alpha <- theta[3]
c <- 0.6515348
lik1 <- sum(dnorm(R20_data,mean = mu, sd = sigma, log = TRUE))
lik2 <- g2 * log(
pnorm(dmg_inverse(l,alpha,l,c,s), mean = mu, sd = sigma) -
pnorm(l, mean = mu, sd = sigma)
)
#lik2 <- 0
lik3 <- sum(sapply(R20R100_data,dmglik,alpha,l,c,s,mu,sigma))
lik4 <- sum(dnorm(R100_data,mean = mu, sd = sigma, log = TRUE))
return(-lik1-lik2-lik3-lik4)
}
s <- 1
alpha <- seq(from = 0.01, to = 0.99, by = 0.01)
neglik <- sapply(alpha,negdmglik_alpha)
plot(alpha, neglik,type = "l", ylab = "neglik")
optimize(negdmglik_alpha,c(.01,.00))
optimize(negdmglik_alpha,c(.01,.99))
plot(alpha[0:50], neglik[0:50],type = "l", ylab = "neglik")
#' The smooth function for the indicator function, which is also called "sigmoid function".
#'
#' @param x, the variable
#' @param s, the hyper parameter, higher s means closer the indicator function
#' @returns the smoothed value.
smooth_ind <- function(x,s){
return(1/(1+exp(-x*s)))
}
#' The damage model, smoothed version of
#' "y* = y* I(c*x > l) + alpha * y * I(c*x < l)"
#'
#' @param y, the original strength
#' @param alpha, the damage parameter
#' @param l, the proof loading level
#' @param c, the threshold parameter. Damage effects happen exceeding c.
#' @param s, the temperature parameter for s
#' @return, the weakened y*, y*<y.
dmg_model <- function(y,alpha,l,c,s){
return(y*smooth_ind(c*y-l,s)+ alpha*y*smooth_ind(l-c*y,s))
}
#' The damage-inverse model, given a weakened ystar, find the original y
#'
#' @param ystar, the weakened strength
#' @param alpha, the damage parameter
#' @param l, the proof loading level
#' @param c, the threshold parameter. Damage effects happen exceeding c.
#' @param s, the temperature parameter for s
#' @return, the original y, y>y*.
dmg_inverse <- function(ystar,alpha,l,c,s){
uniroot((function (x) dmg_model(x,alpha,l,c,s) - ystar), lower = 0, upper = 1000)$root
}
# the abs gradient at damage-inverse
dmg_inverse_grad <- function(ystar,alpha,l,c,s){
abs(numDeriv::grad(func = (function(x) dmg_inverse(x,alpha,l,c,s)),
x  = ystar))
}
# dmg_inverse_grad(42,a lpha,l,c,s)
# ystar <- y*smooth_ind(c*y-l)+ alpha*smooth_ind(l-c*y)
dmglik <- function(ystar,alpha,l,c,s,mu,sigma){
y <- dmg_inverse(ystar,alpha,l,c,s)
dnorm(y, mean = mu, sd = sigma, log = TRUE)+ log(dmg_inverse_grad(ystar,alpha,l,c,s))
}
## plot
set.seed(8888)
# the orignal sample size
N <- 300
mu <- 48
sigma <- 19
#y <- rnorm(N,mean = mu, sd = sigma)
l <-  32
# alpha <- 0.9
# c <- 0.8
# alpha <- 0.45
alpha <- 0.24
c <- 0.65
s <- 1
## data
y <- rnorm(N, mean = mu, sd = sigma )
y <- y[y>0]
y_obs <- list()
# group 1, y^* <y < l
y_obs$group1 <- y[which(y < l)]
# group 2, y^*<l<y
group23 <- y[which(y > l)]
group23_star <- dmg_model(group23,alpha,l,c,s)
y_obs$group2 <- length(group23[which(group23 > l &group23_star < l)])
y_obs$group3 <- group23_star[which(group23_star >l)]
negdmglik_model <- function(theta){
mu <- theta[1]
sigma <- theta[2]
alpha <- theta[3]
c <- theta[4]
lik1 <- sum(dnorm(y_obs$group1,mean = mu, sd = sigma, log = TRUE))
lik2 <- y_obs$group2 * log(
pnorm(dmg_inverse(l,alpha,l,c,s), mean = mu, sd = sigma) -
pnorm(l, mean = mu, sd = sigma)
)
#lik2 <- 0
lik3 <- sum(sapply(y_obs$group3,dmglik,alpha,l,c,s,mu,sigma))
return(-lik1-lik2-lik3)
#return (-lik3)
}
theta0 <- c(mu,sigma,alpha,c)
optimCheck::optim_proj(theta0,
negdmglik_model,xrng = .5,
xnames = c("mu","sigma","alpha","c"))
optimout <- optim(theta0,negdmglik_model,method = "L-BFGS-B",
lower = rep(0.1,4),upper = c(Inf,Inf,1,Inf))
optimCheck::optim_proj(optimout$par,
negdmglik_model,xrng = .5,
xnames = c("mu","sigma","alpha","c"))
optimize(negdmglik_alpha,c(.01,.99))
optimize(negdmglik_alpha,c(.01,.99))
optimize(negdmglik_alpha,c(.01,.99))
bending <- read.csv("bending-pl.csv", header = T)
bending[,1] <- bending[,1]/1000*6.895
l <- 4500/1000*6.895
# bending_mar <- bending[1:195,]
# bending_dmg <- bending[195:341,]
R100_data <- bending[bending[,2] == "R100",1]
R20_data <- bending[bending[,2] == "R20",1]
R20R100_data <- bending[bending[,2] == "R20R100",1]
# 97 pieces breaking in the loading process.
g2 <- 97
# the total sample size
#N <- length(R20_data) + length(R20R100_data) + g2
mu <- 48
sigma <- 19
s <- 1
#' The smooth function for the indicator function, which is also called "sigmoid function".
#'
#' @param x, the variable
#' @param s, the hyper parameter, higher s means closer the indicator function
#' @returns the smoothed value.
smooth_ind <- function(x,s){
return(1/(1+exp(-x*s)))
}
#' The damage model, smoothed version of
#' "y* = y* I(c*x > l) + alpha * y * I(c*x < l)"
#'
#' @param y, the original strength
#' @param alpha, the damage parameter
#' @param l, the proof loading level
#' @param c, the threshold parameter. Damage effects happen exceeding c.
#' @param s, the temperature parameter for s
#' @return, the weakened y*, y*<y.
dmg_model <- function(y,alpha,l,c,s){
return(y*smooth_ind(c*y-l,s)+ alpha*y*smooth_ind(l-c*y,s))
}
#' The damage-inverse model, given a weakened ystar, find the original y
#'
#' @param ystar, the weakened strength
#' @param alpha, the damage parameter
#' @param l, the proof loading level
#' @param c, the threshold parameter. Damage effects happen exceeding c.
#' @param s, the temperature parameter for s
#' @return, the original y, y>y*.
dmg_inverse <- function(ystar,alpha,l,c,s){
uniroot((function (x) dmg_model(x,alpha,l,c,s) - ystar), lower = 0, upper = 1000)$root
}
# the abs gradient at damage-inverse
dmg_inverse_grad <- function(ystar,alpha,l,c,s){
abs(numDeriv::grad(func = (function(x) dmg_inverse(x,alpha,l,c,s)),
x  = ystar))
}
# dmg_inverse_grad(42,a lpha,l,c,s)
# ystar <- y*smooth_ind(c*y-l)+ alpha*smooth_ind(l-c*y)
dmglik <- function(ystar,alpha,l,c,s,mu,sigma){
y <- dmg_inverse(ystar,alpha,l,c,s)
dnorm(y, mean = mu, sd = sigma, log = TRUE)+ log(dmg_inverse_grad(ystar,alpha,l,c,s))
}
logit <- function(x){
return(log(x/(1-x)))
}
expit <- function(x){
1/(1+exp(-x))
}
negdmglik_model <- function(theta){
mu <- theta[1]
sigma <- theta[2]
# alpha <- theta[3]
alpha <- expit(theta[3])
c <- theta[4]
lik1 <- sum(dnorm(R20_data,mean = mu, sd = sigma, log = TRUE))
lik2 <- g2 * log(
pnorm(dmg_inverse(l,alpha,l,c,s), mean = mu, sd = sigma) -
pnorm(l, mean = mu, sd = sigma)
)
#lik2 <- 0
lik3 <- sum(sapply(R20R100_data,dmglik,alpha,l,c,s,mu,sigma))
lik4 <- sum(dnorm(R100_data,mean = mu, sd = sigma, log = TRUE))
return(-lik1-lik2-lik3-lik4)
}
negdmglik_model_grad <- function(theta){
numDeriv::grad(negdmglik_model,theta_test)
}
theta_test <- c(mu,sigma,logit(0.5),.6)
negdmglik_model(theta_test)
theta_test <- c(mu,sigma,logit(0.5),.6)
theta_0 <- c(47.9985218, 18.9804222,logit(0.4548490),  0.6515348)
negdmglik_model(theta_0)
optimout <- optim(par = theta_0,
fn = negdmglik_model,
gr = negdmglik_model_grad,
method = "BFGS")
optimout$par
expit(optimout$par[3])
# [1] 1678.031
#theta_test <- c(47.9985218, 18.9804222,0.4548490,  0.6515348)
s <- 1
negdmglik_model_unconstraint <- function(theta){
mu <- theta[1]
sigma <- theta[2]
# alpha <- theta[3]
alpha <- theta[3]
c <- theta[4]
lik1 <- sum(dnorm(R20_data,mean = mu, sd = sigma, log = TRUE))
lik2 <- g2 * log(
pnorm(dmg_inverse(l,alpha,l,c,s), mean = mu, sd = sigma) -
pnorm(l, mean = mu, sd = sigma)
)
#lik2 <- 0
lik3 <- sum(sapply(R20R100_data,dmglik,alpha,l,c,s,mu,sigma))
lik4 <- sum(dnorm(R100_data,mean = mu, sd = sigma, log = TRUE))
return(-lik1-lik2-lik3-lik4)
}
theta_opt <- optimout$par
theta_opt[3] <- expit(theta_opt[3])
optimCheck::optim_proj(theta_opt,
negdmglik_model_unconstraint ,xrng = .5,
xnames = c("mu","sigma","alpha","c"))
#
## the only plot for alpha
negdmglik_alpha <- function(alpha){
mu <- 47.9985218
sigma <- 18.9804222
# alpha <- theta[3]
c <- 0.6515348
lik1 <- sum(dnorm(R20_data,mean = mu, sd = sigma, log = TRUE))
lik2 <- g2 * log(
pnorm(dmg_inverse(l,alpha,l,c,s), mean = mu, sd = sigma) -
pnorm(l, mean = mu, sd = sigma)
)
#lik2 <- 0
lik3 <- sum(sapply(R20R100_data,dmglik,alpha,l,c,s,mu,sigma))
lik4 <- sum(dnorm(R100_data,mean = mu, sd = sigma, log = TRUE))
return(-lik1-lik2-lik3-lik4)
}
s <- 1
alpha_opt <- optimize(negdmglik_alpha,c(.01,.99))
optimCheck::optim_proj(alpha_opt$minium,
alpha_opt,
xrng = 0.5,
xnames = "alpha")
optimCheck::optim_proj(alpha_opt$minimum,
alpha_opt,
xrng = 0.5,
xnames = "alpha")
optimCheck::optim_proj(alpha_opt$minimum,
negdmglik_alpha,
xrng = 0.5,
xnames = "alpha")
plot(alpha_seq, sapply(alpha_seq,negdmglik_alpha),type = "l", ylab = "neglik")
alpha_seq <- seq(from = 0.01, to = 0.5, length =200)
plot(alpha_seq, sapply(alpha_seq,negdmglik_alpha),type = "l", ylab = "neglik")
alpha_opt$minimum
source("dmg_func.R")
##------------------test the smooth function-----
N <-300
mu <- 48
sigma <- 19
#y <- rnorm(N,mean = mu, sd = sigma)
l <-  32
# alpha <- 0.9
# c <- 0.8
alpha <- 0.45
c <- 0.65
s <- 1
## test the gradient
set.seed(8888)
N <- 1000
mu <- 48
sigma <- 19
#y <- rnorm(N,mean = mu, sd = sigma)
l <-  32
alpha <- 0.45
c <- 0.65
s <- 1
dmg_inverse_grad(40,alpha,l,c,s)
eps <- 1e-4
(dmg_inverse(40+eps,alpha,l,c,s)-dmg_inverse(40-eps,alpha,l,c,s))/(2*eps)
## test the gradient
set.seed(8888)
N <- 1000
mu <- 48
sigma <- 19
#y <- rnorm(N,mean = mu, sd = sigma)
l <-  32
alpha <- 0.45
c <- 0.65
s <- 1
dmg_inverse_grad(40,alpha,l,c,s)
eps <- 1e-6
(dmg_inverse(40+eps,alpha,l,c,s)-dmg_inverse(40-eps,alpha,l,c,s))/(2*eps)
dmg_inverse_numgrad <- function(ystar,alpha,l,c,s,eps){
return(abs(dmg_inverse(ystar+eps,alpha,l,c,s)
-dmg_inverse(ystar-eps,alpha,l,c,s)/(2*eps)))
}
eps <- 1e-6
dmg_inverse_numgrad(40,alpha,l,c,s, eps )
dmg_inverse_grad(40,alpha,l,c,s)
dmg_inverse_numgrad <- function(ystar,alpha,l,c,s,eps){
abs(dmg_inverse(ystar+eps,alpha,l,c,s)
-dmg_inverse(ystar-eps,alpha,l,c,s)/(2*eps))
}
eps <- 1e-6
dmg_inverse_grad(40,alpha,l,c,s)
dmg_inverse_numgrad(40,alpha,l,c,s, eps )
dmg_inverse(ystar+eps,alpha,l,c,s)
dmg_inverse(40+eps,alpha,l,c,s)
-dmg_inverse(40-eps,alpha,l,c,s)
dmg_inverse_numgrad <- function(ystar,alpha,l,c,s,eps){
abs(dmg_inverse(ystar+eps,alpha,l,c,s) -dmg_inverse(ystar-eps,alpha,l,c,s)/(2*eps))
}
eps <- 1e-6
dmg_inverse_grad(40,alpha,l,c,s)
dmg_inverse_numgrad(40,alpha,l,c,s,eps )
dmg_inverse_numgrad <- function(ystar,alpha,l,c,s,eps){
abs((dmg_inverse(ystar+eps,alpha,l,c,s) -dmg_inverse(ystar-eps,alpha,l,c,s))/(2*eps))
}
eps <- 1e-6
dmg_inverse_grad(40,alpha,l,c,s)
dmg_inverse_numgrad(40,alpha,l,c,s,eps )
## plot
set.seed(8888)
# the orignal sample size
N <- 300
mu <- 48
sigma <- 19
#y <- rnorm(N,mean = mu, sd = sigma)
l <-  32
# alpha <- 0.24
alpha <- 0.45
c <- 0.65
s <- 1
## data
y <- rnorm(N, mean = mu, sd = sigma )
y <- y[y>0]
y_obs <- list()
# group 1, y^* <y < l
y_obs$group1 <- y[which(y < l)]
# group 2, y^*<l<y
group23 <- y[which(y > l)]
group23_star <- dmg_model(group23,alpha,l,c,s)
y_obs$group2 <- length(group23[which(group23 > l &group23_star < l)])
y_obs$group3 <- group23_star[which(group23_star >l)]
# increasing order now
#y_obs$group3 <- y_obs$group3[order(y_obs$group3)]
theta0 <- c(mu,sigma,alpha,c)
# optimCheck::optim_proj(theta0,
#                        negdmglik_model,xrng = .5,
#                        xnames = c("mu","sigma","alpha","c"))
#
#
# optimout <- optim(theta0,negdmglik_model,method = "L-BFGS-B",
#                   lower = rep(0.1,4),upper = c(Inf,Inf,1,Inf))
#
# optimCheck::optim_proj(optimout$par,
#                        negdmglik_model,xrng = .5,
#                        xnames = c("mu","sigma","alpha","c"))
negdmglik_alpha<- function(theta){
alpha <- theta
lik1 <- sum(dnorm(y_obs$group1,mean = mu, sd = sigma, log = TRUE))
lik2 <- y_obs$group2 * log(
pnorm(dmg_inverse(l,alpha,l,c,s), mean = mu, sd = sigma) -
pnorm(l, mean = mu, sd = sigma)
)
#lik2 <- 0
lik3 <- sum(sapply(y_obs$group3,dmglik,alpha,l,c,s,mu,sigma))
return(-lik1-lik2-lik3)
}
alpha_seq <- seq(from = 0.1, to = 0.5, length = 200)
dmglik_value <- sapply(alpha_seq,negdmglik_alpha)
plot(alpha_seq,dmglik_value,type = "l")
optimize(negdmglik_alpha,c(.1,.2))
optimize(negdmglik_alpha,c(.15,.2))
alpha_seq <- seq(from = 0.15, to = 0.2, length = 100)
dmglik_value <- sapply(alpha_seq,negdmglik_alpha)
plot(alpha_seq,dmglik_value,type = "l")
optimize(negdmglik_alpha,c(.175,.182))
alpha_seq <- seq(from = 0.175, to = 0.182, length = 100)
dmglik_value <- sapply(alpha_seq,negdmglik_alpha)
plot(alpha_seq,dmglik_value,type = "l")
optimize(negdmglik_alpha,c(.179,.180))
which.min(dmglik_value)
alpha_seq[69]
negdmglik_alpha(0.1798) -negdmglik_alpha(0.18)
log(
pnorm(dmg_inverse(l,0.1798,l,c,s), mean = mu, sd = sigma) -
pnorm(l, mean = mu, sd = sigma)
)
log(
pnorm(dmg_inverse(l,0.18,l,c,s), mean = mu, sd = sigma) -
pnorm(l, mean = mu, sd = sigma)
)
# 0.44 diff
sum(sapply(y_obs$group3,dmglik,0.1798,l,c,s,mu,sigma)[-50])-sum(sapply(y_obs$group3,dmglik,0.180,l,c,s,mu,sigma)[-50])
sapply(y_obs$group3,dmglik,0.1798,l,c,s,mu,sigma)-sapply(y_obs$group3,dmglik,0.180,l,c,s,mu,sigma)
order(sapply(y_obs$group3,dmglik,0.1798,l,c,s,mu,sigma)-
sapply(y_obs$group3,dmglik,0.180,l,c,s,mu,sigma),decreasing = TRUE )
(sapply(y_obs$group3,dmglik,0.1798,l,c,s,mu,sigma)-
sapply(y_obs$group3,dmglik,0.180,l,c,s,mu,sigma))[10]
y_obs$group3[50]
dmglik(36.09944,0.1798,l,c,s,mu,sigma)
dmglik(36.09944,0.18,l,c,s,mu,sigma)
log(dmg_inverse_grad(36.09944,0.1798,l,c,s))
log(dmg_inverse_grad(36.09944,0.18,l,c,s))
alpha_seq <- seq(from = 0.01, to = 0.99, length = 200)
sapply(alpha_seq, function(alpha)(log(dmg_inverse_grad(36.09944,alpha,l,c,s))))
plot(alpha_seq ,
sapply(alpha_seq, function(alpha)(log(dmg_inverse_grad(36.09944,alpha,l,c,s)))),
type = "l",ylab = "neglik"
)
alpha_seq <- seq(from = 0.1, to = 0.3, length = 200)
sapply(alpha_seq, function(alpha)(log(dmg_inverse_grad(36.09944,alpha,l,c,s))))
plot(alpha_seq ,
sapply(alpha_seq, function(alpha)(log(dmg_inverse_grad(36.09944,alpha,l,c,s)))),
type = "l",ylab = "neglik"
)
# the inverse function
dmg_inverse <- function(ystar,alpha,l,c,s){
uniroot((function (x) dmg_model(x,alpha,l,c,s) - ystar), lower = 0, upper = 1000)$root
}
plot(alpha_seq,
sapply(alpha_seq, dmg_inverse,ystar =36.0994, l,c,s),
type = "l", xlab = "alpha", ylab = "y")
dmg_inverse(ystar,alpha,l,c,s)
# test the first part
alpha_seq <- seq(from = 0.15, to = 0.25, length = 100)
plot(alpha_seq,
sapply(alpha_seq, function(alpha){log(dmg_inverse_grad(y_obs$group3[50],alpha,l,c,s))
}),
type = "l",xlab = "alpha", ylab = "normal part")
plot(alpha_seq,
sapply(alpha_seq, function(alpha){log(dmg_inverse_numgrad(y_obs$group3[50],alpha,l,c,s,eps))
}),
type = "l",xlab = "alpha", ylab = "normal part")
plot(alpha_seq,
sapply(alpha_seq, function(alpha){log(dmg_inverse_numgrad(y_obs$group3[50],alpha,l,c,s,eps))
}),
type = "l",xlab = "alpha", ylab = "normal part")
plot(alpha_seq,
sapply(alpha_seq, function(alpha){log(dmg_inverse_numgrad(y_obs$group3[50],alpha,l,c,s,eps))
}),
type = "l",xlab = "alpha", ylab = "normal part")
plot(alpha_seq,
sapply(alpha_seq, function(alpha){log(dmg_inverse_numgrad(y_obs$group3[50],alpha,l,c,s,eps))
}),
type = "l",xlab = "alpha", ylab = "normal part")
plot(alpha_seq,
sapply(alpha_seq, function(alpha){log(dmg_inverse_numgrad(y_obs$group3[50],alpha,l,c,s,eps))
}),
type = "l",xlab = "alpha", ylab = "normal part")
# test the first part
alpha_seq <- seq(from = 0.15, to = 0.25, length = 100)
plot(alpha_seq,
sapply(alpha_seq, function(alpha){log(dmg_inverse_grad(y_obs$group3[50],alpha,l,c,s))
}),
type = "l",xlab = "alpha", ylab = "normal part")
plot(alpha_seq,
sapply(alpha_seq, function(alpha){log(dmg_inverse_numgrad(y_obs$group3[50],alpha,l,c,s,eps))
}),
type = "l",xlab = "alpha", ylab = "normal part")
